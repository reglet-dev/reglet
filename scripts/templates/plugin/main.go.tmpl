// Package main provides a {{.Name}} plugin for Reglet.
// This is compiled to WASM and loaded by the Reglet runtime.
//
// Uses Go 1.24+ //go:wasmexport directive for function exports.
package main

import (
	"encoding/json"
	"fmt"
	"unsafe"
)

// Memory management for passing data between host and plugin.
// allocations keeps a reference to allocated memory to prevent the GC from collecting it.
// This effectively "pins" the memory until the host explicitly releases it.
var allocations = make(map[uint32][]byte)

// allocate reserves memory in the WASM linear memory and returns a pointer.
// The host can read from this pointer.
//
//go:wasmexport allocate
func allocate(size uint32) uint32 {
	if size == 0 {
		return 0
	}

	buf := make([]byte, size)
	ptr := uint32(uintptr(unsafe.Pointer(&buf[0])))

	// PIN THE MEMORY: Store the slice in a global map so the GC sees it as "in use"
	allocations[ptr] = buf

	return ptr
}

// deallocate frees memory by removing the reference, allowing the GC to collect it.
//
//go:wasmexport deallocate
func deallocate(ptr uint32, size uint32) {
	delete(allocations, ptr)
}

// Helper: copyToMemory writes data to WASM linear memory at the given pointer.
func copyToMemory(ptr uint32, data []byte) {
	dest := unsafe.Slice((*byte)(unsafe.Pointer(uintptr(ptr))), len(data))
	copy(dest, data)
}

// Helper: readFromMemory reads data from WASM linear memory at the given pointer.
func readFromMemory(ptr uint32, length uint32) []byte {
	src := unsafe.Slice((*byte)(unsafe.Pointer(uintptr(ptr))), length)
	data := make([]byte, length)
	copy(data, src)
	return data
}

// Helper: marshalToPtr marshals data to JSON and returns a pointer to it.
func marshalToPtr(data interface{}) uint32 {
	jsonData, err := json.Marshal(data)
	if err != nil {
		return 0
	}

	ptr := allocate(uint32(len(jsonData)))
	copyToMemory(ptr, jsonData)
	return ptr
}

// Helper: successResponse creates a successful observation result.
func successResponse(data map[string]interface{}) uint32 {
	result := map[string]interface{}{"status": true}
	for key, value := range data {
		result[key] = value
	}
	return marshalToPtr(result)
}

// Helper: errorResponse creates an error observation result.
func errorResponse(message string) uint32 {
	result := map[string]interface{}{
		"status": false,
		"error":  message,
	}
	return marshalToPtr(result)
}

// describe returns plugin metadata as JSON in WASM memory.
//
//go:wasmexport describe
func describe() uint32 {
	info := map[string]interface{}{
		"name":        "{{.Name}}",
		"version":     "1.0.0",
		"description": "{{.Description}}",
		"capabilities": []map[string]string{
			{
				"kind":    "{{.CapabilityKind}}",
				"pattern": "{{.CapabilityPattern}}",
			},
		},
	}

	return marshalToPtr(info)
}

// schema returns configuration schema as JSON.
//
//go:wasmexport schema
func schema() uint32 {
	configSchema := map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			// TODO: Add your config fields here
			// Example:
			// "url": map[string]interface{}{
			//     "type":        "string",
			//     "description": "URL to check",
			// },
		},
		"required": []string{
			// TODO: Add required field names here
		},
	}

	return marshalToPtr(configSchema)
}

// observe executes the observation with the given configuration.
//
//go:wasmexport observe
func observe(configPtr uint32, configLen uint32) uint32 {
	// Read config from WASM memory
	configData := readFromMemory(configPtr, configLen)

	var config map[string]interface{}
	if err := json.Unmarshal(configData, &config); err != nil {
		return errorResponse(fmt.Sprintf("failed to parse config: %v", err))
	}

	// TODO: Validate required config fields
	// Example:
	// url, ok := config["url"].(string)
	// if !ok || url == "" {
	//     return errorResponse("missing required field: url")
	// }

	// TODO: Implement your observation logic here
	// This is where you perform the actual check/validation

	// TODO: Return appropriate response
	// Example success:
	// return successResponse(map[string]interface{}{
	//     "field": "value",
	//     "count": 123,
	// })

	// Example error:
	// return errorResponse("something went wrong")

	return errorResponse("not implemented yet")
}

func main() {
	// Required for WASM, but never called
}
